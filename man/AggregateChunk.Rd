% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/AggregateChunk.R
\name{AggregateChunk}
\alias{AggregateChunk}
\title{Aggregate chunks to create smaller chunks}
\usage{
AggregateChunk(Data, Filter = 1 == 1, Aggregation = .N, By = NULL,
  ...)
}
\arguments{
\item{Data}{This is a required field and is usually a TAP chunk but it can be any item of class "data.table" or "data.frame".
If the user submits a data frame then this will first be converted to a data table before
the calculated column is added.This is because data tables are far more efficient in R than a
data frame. The resulting table that is returned by this function will also be a data table even
if a data frame was submitted.}

\item{Filter}{Optional filter to apply to the chunk.  The calculation is only defined on the rows that meet
the criteria in this filter.  If you are using this function to change a column that already exists then rows that don't
match the filter will not be changed and only rows that match the filter will have a new value placed in the column.
If you are using this function to create a new column then rows that don't match the filter will contain NA and the rows
that match will have the results of the calculation. The default is no filtering.}

\item{Aggregation}{This is an equation that follows the syntax of R to define the aggregation. The default aggregation is
a count of rows.}

\item{By}{This is an optional field that allows the <calculation> to be computed for certain groups and then each member of that group
will be given the result of the calculation. The default is to have no grouping.}
}
\value{
The function returns the aggregated data chunk.
}
\description{
Aggregate chunks into a smaller chunks by the metadata selected by the user.
}
\section{Parameter Order}{

The function expects the parameters to be passed in the following order: Data, Filter, Aggregation and By.  A common scenario
will be to use just Data and Calculation without a filter or a by clause and in this case the system will need to understand that the filter is blank.
There are two ways to do this:
\tabular{ll}{
Leave the filter blank: \tab AggregateChunk(TestEmailChunk, , sum(value))\cr
Name the parameters:    \tab AggregateChunk(TestEmailChunk, Aggregation = sum(value))\cr
}
We recommend always naming the parameters for all TAPChunks functions to avoid errors in
interpretation.  The first example that we gave requires a extra comma to specify that filter is blank.
The second example does not require the extra comma because we explicitly name the parameters.
}

\section{Defining the Aggregation}{

The key part of the aggregation definition is in the aggregate parameter.
Aggregations can contain constants, variable names, column names, operators, functions and parenthesis. \cr
The system can manipulate various types of data and there are six elemental (also called \emph{atomic}) data types as follows:\cr
\enumerate{
\item{\strong{Raw:} This is a single byte value ranging from 0 to 255.  It is often expressed in binary or in hexadecimal. This type is very rarely used as it cannot
be manipulated using the standard mathematical functions such as add and subtract.  }
\item{\strong{Logical:} This is one of two boolean states - FALSE and TRUE. }
\item{\strong{Integer:} This is a 32 bit integer able to hold numbers in the range -2,147,483,647 to 2,147,483,647 inclusive.}
\item{\strong{Numeric:} This is a floating point number following the IEC 60559 standard. It uses 53 bit of precision and holds numbers from 2e-308 to 2e+308.}
\item{\strong{Complex:} This is a complex number formed of Real and Imaginary parts.  These are both Numeric.}
\item{\strong{String:} This is a sequence of characters.}
}  \cr
\strong{Constants:}\cr
An aggregation may not just be a constant but constants may be used as in the aggragation formula.
Here are some examples of aggregations that use constants:
\preformatted{
# An aggregation cannot be a constant and this will give an error
AggregateChunk(TestEmailChunk, Aggregation =  1)}
\preformatted{
# We can use a constant in a calculation
AggregateChunk(TestEmailChunk, Aggregation =  sum(value) * 2.5)}
\tabular{r}{
\strong{V1}\cr
6867.5
}
\strong{Variable Names:} \cr
If you have defined a variable in your script then it may be used in a calculation: \cr
\preformatted{
#We Define a variable...
weight <- 0.2345
# ...and use our variable in the calculation
AggregateChunk(TestEmailChunk, Aggregation =  sum(value) * weight)
}
\tabular{r}{
\strong{V1} \cr
644.1715
}
\strong{Operators:}\cr
We have already shown some examples that use operators to aggregate and we now present here the most common operators that you may wish to use
in a calculation. They are listed in precedence groups, from highest to lowest and the function will apply higher operations before
applying lower operations. For example 1 + 2 * 3 resolves to 7. Parentheses will always overide this behaviour so that (1 + 2) * 3 resolves to 9.  These are the main
operators:
\tabular{lll}{
\strong{Symbols}\tab \strong{Meaning}       \tab \strong{Example}  \cr
^               \tab Exponentiation         \tab 2^10 = 1024       \cr
- +             \tab Unary minus and plus   \tab +5 * -5 = -25     \cr
* /             \tab Multiply and divide    \tab 25 / 5 * 100 = 500\cr
+ -             \tab Add and subtract       \tab 10 + 5 - 3 = 12   \cr
< > <= >= == != \tab Ordering and comparison\tab                   \cr
                \tab Less Than            : \tab 3 <  10 = TRUE    \cr
                \tab Greater Than         : \tab 3 >  10 = FALSE   \cr
                \tab Less Than or Equal   : \tab 3 <= 10 = TRUE    \cr
                \tab Greater Than or Equal: \tab 3 >= 10 = FALSE   \cr
                \tab Equal                : \tab 3 == 10 = FALSE   \cr
                \tab Not Equal            : \tab 3 != 10 = TRUE    \cr
!               \tab Negation               \tab !FALSE = TRUE     \cr
&               \tab Logical AND            \tab TRUE & FALSE = FALSE\cr
|               \tab Logical OR             \tab TRUE | FALSE 0 TRUE\cr
}
It is important to understand the concept of coercion when using operators.  In general the operators ^ - + * and / require operands that are numbers; in this context a number is
either integer, numeric or complex.  The other operators < > <= >= == != work with numbers and strings.  The system will use coercion to convert the data
to try and make sense of other data types. For example TRUE + FALSE is valid.  The system will interpret FALSE and the integer 0 and TRUE as the integer 1.  This means that
the system will consider that FALSE < TRUE is a true statement. \cr \cr
\strong{Functions:}\cr
Aggregations normally use functions and these functions may be those that are defined in R or they may be defined by the user.  When using a function it is important
to consider the cardinality of the inputs and the result.  Some functions are designed to transform a single value to another single value, for example sqrt(n). Using this
type of function will not aggregate the data (but will return a result).
It is more usual to use an aggregating functions:
\tabular{ll}{
\strong{Function}\tab \strong{Effect}\cr
length(x) \tab Number of rows\cr
sum(x)    \tab Sum\cr
mean(x)   \tab Arithmetic mean\cr
median(x) \tab Median\cr
min(x)    \tab Minimum\cr
max(x)    \tab Maximum\cr
sd(x)     \tab Standard Deviation\cr
var(x)    \tab Variance\cr
}

\strong{Parentheses:}\cr
Parentheses may be used to control order of opertions in the calculation.
}

\section{Combining Aggregations with Filters}{

The examples given so far have applied the aggregation to every row in the submitted data, however a filter can be used to aggregate a subset of rows.
The filter definition follows the same syntax as the main calculation but it must return a logical value of either TRUE or FALSE.  The aggregation only
includes the rows for which the filter returns TRUE. Here are some examples:
\preformatted{
AggregateChunk(TestEmailChunk, Filter = timestamp == "2015M01", Aggregation = sum(value))
}
\tabular{r}{
\strong{V1}\cr
1495
}
Most functions have a mechanism to ignore the NA values e.g. sum(value, na.rm = TRUE).
}

\section{Grouping Aggregations}{

When we wish to perform the aggregation for different groups of data we can use the By parameter to do this.  Supose that we want
to know the mean of a value for each timestamp:
\preformatted{
AggregateChunk(TestEmailChunk, Aggregation = mean(value), By = "timestamp")
}
\tabular{rr}{
\strong{timestamp}\tab \strong{V1}\cr
2015M01 \tab 2.990\cr
2016M01 \tab 2.504
}
}

\examples{
AggregateChunk(TestEmailChunk, Aggregation = mean(value), By = "timestamp")
AggregateChunk(TestEmailChunk, Aggregation = sum(value), By = "variable")
AggregateChunk(TestEmailChunk)
}
\seealso{
\code{\link{TAPChunks}}

Other Chunk Manipulators: \code{\link{CalculateColumn}},
  \code{\link{FilterChunk}}, \code{\link{JoinChunks}},
  \code{\link{MergeChunks}}, \code{\link{SelectColumns}},
  \code{\link{ShapeChunk}}, \code{\link{ShowSampleSize}}
}
\author{
JTA - The Data Scientists
}
\concept{Chunk Manipulators}
